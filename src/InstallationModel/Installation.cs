namespace InstallationModel
{
    // One of the concerns here is use of 'int' as the data type for IDs. If more information were available, it might become apparent that this is overly restrictive, and IDs need to be more flexible.
    // Were this a 'genuine' development, I would at least discuss the possibility of defining an ID class, so that the ID type can be varied as requirements evolve, or simply using a
    // catch-all type, like string. However, as the requirements are fairly narrow for this exercise, I've elected to use 'int' for IDs, as it's apparent that this is sufficient.

    /// <summary>
    /// Models data related to a single installation of an application on a single computer by a single user.
    /// </summary>
    public class Installation
    {
        /// <summary>
        /// The numeric ID of the computer the Installation applies to.
        /// </summary>
        public int ComputerId { get; }

        /// <summary>
        /// The numeric ID of the user who owns the Installation.
        /// </summary>
        public int UserId { get;  }

        /// <summary>
        /// The numeric ID of the application installed by the Installation.
        /// </summary>
        public int ApplicationId { get;  }

        /// <summary>
        /// The type of computer the installation applies to - denormal data.
        /// Ideally, this information should be normalised out of the installations to avoid possible conflicts and data integrity issues.
        /// </summary>
        public ComputerType ComputerType { get; }

        /// <summary>
        /// Construct a new installation. All data items must be specified.
        /// </summary>
        /// <param name="computerId">The computer ID as an int.</param>
        /// <param name="userId">The user ID as an int.</param>
        /// <param name="applicationId">The application ID as an int.</param>
        /// <param name="computerType">The computer type, drawn from the ComputerType enumeration.</param>
        public Installation(int computerId, int userId, int applicationId, ComputerType computerType)
        {
            ComputerId = computerId;
            UserId = userId;
            ApplicationId = applicationId;
            ComputerType = computerType;
        }

        /// <summary>
        /// Equality operator for use in containers.
        /// Returns true if the other object is equivalent to this one.
        /// Ensures that Installation objects are properly unique in sets.
        /// </summary>
        /// <param name="other">The other object to test.</param>
        /// <returns>True if the objects are equivalent.</returns>
        public override bool Equals(object other)
        {
            return other is Installation installation &&
                   ComputerId == installation.ComputerId &&
                   UserId == installation.UserId &&
                   ApplicationId == installation.ApplicationId &&
                   ComputerType == installation.ComputerType;
        }

        /// <summary>
        /// Generates a hashcode for use in hash based containers.
        /// Implementation auto-generated by Resharper, along with mysterious magic numbers.
        /// Presumably R#'s numbers are intended to give reasonably well distributed hash-bucket allocations.
        /// </summary>
        /// <returns>int hashcode for the Installation data.</returns>
        public override int GetHashCode()
        {
            var hashCode = -308356996;
            hashCode = hashCode * -1521134295 + ComputerId.GetHashCode();
            hashCode = hashCode * -1521134295 + UserId.GetHashCode();
            hashCode = hashCode * -1521134295 + ApplicationId.GetHashCode();
            hashCode = hashCode * -1521134295 + ComputerType.GetHashCode();
            return hashCode;
        }
    }
}
